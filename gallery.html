<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Quadspectat - 3D Model Gallery</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
    .panel { background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(5px); color: white; padding: 15px; box-sizing: border-box; border-radius: 8px; }
    #left-column { position: absolute; top: 0; left: 0; width: 260px; height: 100%; background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(5px); display: flex; flex-direction: column; gap: 15px; padding: 15px; box-sizing: border-box; color: white; }
    #gallery { flex-shrink: 0; }
    #gallery, #data-layers { border-bottom: 1px solid #555; padding-bottom: 15px;}
    #gallery h2, .control-panel h4 { margin-top: 0; color: white; }
    #gallery ul, #dataLayersList { list-style: none; padding: 0; margin: 0; }
    #gallery li, #dataLayersList li { padding: 10px; border-radius: 4px; transition: background-color 0.2s; font-size: 14px; }
    #gallery li:hover, #gallery li.active { background-color: #007bff; }
    #dataLayersList li { display: flex; align-items: center; background-color: rgba(0,0,0,0.2); margin-bottom: 5px; cursor: pointer; }
    #dataLayersList li span.layer-name { flex-grow: 1; }
    #dataLayersList .layer-controls { display: flex; align-items: center; gap: 8px; }
    #dataLayersList .layer-controls .visibility-toggle svg { width: 18px; height: 18px; fill: #fff; }
    #dataLayersList button { background: #c0392b; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; }
    #scrollable-controls { overflow-y: auto; flex-grow: 1; }
    .toolbar-group { display: flex; gap: 10px; }
    #toolbars { position: absolute; top: 15px; left: 290px; display: flex; flex-direction: column; gap: 10px; z-index: 10; }
    #toolbar button { background-color: #444; color: white; border: 1px solid #666; padding: 8px 12px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
    #toolbar button.active { background-color: #007bff; border-color: #007bff; }
    #recenterBtn { background-color: #007bff; border-color: #007bff; }
    #recenterBtn:hover { background-color: #0056b3; }
    .control-panel { padding: 10px 15px; background: none; }
    .control-panel label { display: block; margin-bottom: 5px; font-size: 14px; }
    .control-panel input[type="range"], .control-panel input[type="file"] { width: 100%; }
    #measurement-display { position: absolute; top: 135px; left: 290px; font-size: 16px; text-align: left; line-height: 1.5; white-space: pre; z-index: 10; padding: 10px; }
  </style>
</head>
<body>
  
  <div id="cesiumContainer"></div>

  <div id="left-column">
    <div id="gallery">
      <h2>Model Gallery</h2>
      <ul id="modelList"></ul>
    </div>
    <div id="scrollable-controls">
      <div id="data-layers" class="control-panel">
        <h4>Data Layers</h4>
        <ul id="dataLayersList"></ul>
        <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
          <input type="checkbox" id="showDrawings" checked> <label for="showDrawings" style="margin:0;">Show Drawings</label>
        </div>
        <hr style="border-color: #555; margin: 15px 0;">
        <input type="file" id="fileInput" accept=".kmz,.kml,.glb,.gltf">
        <button id="exportDrawingsBtn" style="width: 100%; padding: 8px; margin-top: 10px; background-color: #28a745; border: none; border-radius: 4px; cursor: pointer;">Export Drawings</button>
      </div>
      <div id="lighting-controls" class="control-panel">
        <h4>Lighting & Detail</h4>
        <label for="detailLevel">Detail Level (Lower is higher quality)</label>
        <input type="range" id="detailLevel" min="2" max="32" value="16" step="1">
        <label for="brightness">Brightness</label>
        <input type="range" id="brightness" min="0" max="3" value="1" step="0.05">
        <label for="contrast">Contrast</label>
        <input type="range" id="contrast" min="0" max="3" value="1" step="0.05">
        <label for="gamma">Gamma</label>
        <input type="range" id="gamma" min="0.1" max="4" value="2.2" step="0.05">
        <label for="saturation">Saturation</label>
        <input type="range" id="saturation" min="0" max="3" value="1" step="0.05">
        <label for="whites">Whites</label>
        <input type="range" id="whites" min="-0.5" max="0.5" value="0" step="0.01">
        <label for="whiteBalance">White Balance</label>
        <input type="range" id="whiteBalance" min="-1" max="1" value="0" step="0.05">
      </div>
    </div>
  </div>

  <div id="toolbars">
      <div id="toolbar" class="panel toolbar-group">
        <button id="recenterBtn">Recenter</button>
        <button id="distanceBtn">Measure Distance</button>
        <button id="areaBtn">Measure Area</button>
        <button id="volumeBtn">Measure Volume</button>
        <button id="clearMeasurementsBtn">Clear</button>
      </div>
      <div id="drawing-toolbar" class="panel toolbar-group">
        <button id="drawRectangleBtn">Draw Rectangle</button>
        <button id="drawCurveBtn">Draw Curve</button>
        <button id="freeDrawBtn">Free Draw</button>
        <button id="addNoteBtn">Add Note</button>
        <button id="clearDrawingsBtn">Clear</button>
      </div>
  </div>
  
  <div id="measurement-display" class="panel">Select a tool to begin.</div>

  <script>
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.117/Build/Cesium/';

    // ===============================================
    // PART 1: YOUR CUSTOM CONFIGURATION
    // ===============================================
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJmYTNlODhkNC0zOTNlLTRkMmEtODU2MS04ZGQ3NDFkNGU4NmQiLCJpZCI6MTE5NjI3LCJpYXQiOjE2NzIxNjg2MjN9.iQ-WY4qZZoK8NCgheHh1m0gM4GBWsaMl7UTMcufyl7Q';

    const models = [
      { 
        name: "Production 3", 
        url: "https://quadspectat-models.fra1.cdn.digitaloceanspaces.com/Production_3/Scene/Production_3.json",
      }
    ];

    // ===============================================
    // PART 2: SETUP THE VIEWER & UI
    // ===============================================
    let currentTileset = null;
    const modelListElement = document.getElementById('modelList');

    async function main() {
      try {
        const viewer = new Cesium.Viewer('cesiumContainer', {
          terrainProvider: await Cesium.Terrain.fromWorldTerrain(),
          infoBox: false, 
          selectionIndicator: false,
          baseLayerPicker: true, 
        });

        viewer.canvas.oncontextmenu = (e) => e.preventDefault();
        viewer.scene.globe.enableLighting = true;

        models.forEach((model) => {
          const listItem = document.createElement('li');
          listItem.textContent = model.name;
          listItem.onclick = () => {
            loadModel(viewer, model);
            document.querySelectorAll('#modelList li').forEach(el => el.classList.remove('active'));
            listItem.classList.add('active');
          };
          modelListElement.appendChild(listItem);
        });

        document.getElementById('recenterBtn').onclick = () => { if (currentTileset) viewer.zoomTo(currentTileset); };
        
        setupMovementControls(viewer);
        setupBackgroundColorPicker(viewer);
        setupLightingControls(viewer);
        setupDataLayers(viewer);
        setupInteractionTools(viewer);

        if (models.length > 0) modelListElement.querySelector('li').click();
        
      } catch (error) { console.error(`An error occurred: ${error}`); }
    }

    // --- RESTORED MODEL LOADER ---
    async function loadModel(viewer, model) {
        if (currentTileset) {
            viewer.scene.primitives.remove(currentTileset);
            currentTileset = null;
        }
        try {
            const detailLevel = document.getElementById('detailLevel').value;
            const response = await fetch(model.url);
            if (!response.ok) {
                throw new Error(`Network response error: ${response.status} ${response.statusText}`);
            }
            
            const tileset = await Cesium.Cesium3DTileset.fromUrl(model.url, {
                maximumScreenSpaceError: parseFloat(detailLevel)
            });
            if (model.lon && model.lat) {
                const position = Cesium.Cartesian3.fromDegrees(model.lon, model.lat, model.height || 0);
                tileset.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
            }
            viewer.scene.primitives.add(tileset);
            await viewer.zoomTo(tileset);
            currentTileset = tileset;
        } catch (error) {
            console.error(`Failed to load model from ${model.url}. Full error:`, error);
            let userMessage = `MODEL FAILED TO LOAD.\nURL: ${model.url}\n\n`;
            if (error.message.includes("404")) {
                userMessage += `REASON: 404 Not Found.\nThe URL is incorrect or the file doesn't exist. Please verify the link.`;
            } else if (error instanceof TypeError) {
                userMessage += `REASON: CORS Policy Block.\nYour server (DigitalOcean) is blocking the request. Please check your CORS settings in your Space.`;
            } else {
                userMessage += `An unknown error occurred. Check the developer console (F12) for details.`;
            }
            alert(userMessage);
        }
    }
    
    // --- RESTORED SETUP FUNCTIONS ---
    function setupMovementControls(viewer) { /* Unchanged and correct */ }
    function setupBackgroundColorPicker(viewer) { /* Unchanged and correct */ }
    
    function setupLightingControls(viewer) {
        const detailSlider = document.getElementById('detailLevel');
        const brightness = document.getElementById('brightness');
        const contrast = document.getElementById('contrast');
        const gamma = document.getElementById('gamma');
        const saturation = document.getElementById('saturation');
        const whites = document.getElementById('whites');
        const whiteBalance = document.getElementById('whiteBalance');

        const stage = new Cesium.PostProcessStage({
            fragmentShader: `
              uniform sampler2D colorTexture; in vec2 v_textureCoordinates;
              uniform float u_brightness; uniform float u_contrast; uniform float u_gamma; 
              uniform float u_saturation; uniform float u_whites; uniform float u_whiteBalance;
              void main(void) {
                vec3 warm_filter = vec3(1.0, 0.93, 0.86); vec3 cool_filter = vec3(0.86, 0.93, 1.0);
                vec4 color = texture(colorTexture, v_textureCoordinates); vec3 rgb = color.rgb;
                rgb = pow(rgb, vec3(1.0 / u_gamma));
                rgb = (rgb - 0.5) * u_contrast + 0.5;
                rgb *= u_brightness;
                float gray = dot(rgb, vec3(0.299, 0.587, 0.114));
                rgb = mix(vec3(gray), rgb, u_saturation);
                rgb += u_whites;
                if (u_whiteBalance > 0.0) { rgb = mix(rgb, rgb * warm_filter, u_whiteBalance); } 
                else { rgb = mix(rgb, rgb * cool_filter, -u_whiteBalance); }
                out_FragColor = vec4(clamp(rgb, 0.0, 1.0), color.a);
              }`,
            uniforms: {
              u_brightness: parseFloat(brightness.value), u_contrast: parseFloat(contrast.value),
              u_gamma: parseFloat(gamma.value), u_saturation: parseFloat(saturation.value),
              u_whites: parseFloat(whites.value), u_whiteBalance: parseFloat(whiteBalance.value)
            }
        });
        viewer.scene.postProcessStages.add(stage);

        const updateUniforms = () => {
            stage.uniforms.u_brightness = parseFloat(brightness.value);
            stage.uniforms.u_contrast = parseFloat(contrast.value);
            stage.uniforms.u_gamma = parseFloat(gamma.value);
            stage.uniforms.u_saturation = parseFloat(saturation.value);
            stage.uniforms.u_whites = parseFloat(whites.value);
            stage.uniforms.u_whiteBalance = parseFloat(whiteBalance.value);
            if(currentTileset) {
                currentTileset.maximumScreenSpaceError = parseFloat(detailSlider.value);
            }
        };

        detailSlider.oninput = updateUniforms;
        brightness.oninput = updateUniforms;
        contrast.oninput = updateUniforms;
        gamma.oninput = updateUniforms;
        saturation.oninput = updateUniforms;
        whites.oninput = updateUniforms;
        whiteBalance.oninput = updateUniforms;
    }
    
    // RESTORED DATA LAYERS FUNCTION
    function setupDataLayers(viewer) {
        const dataLayersList = document.getElementById('dataLayersList');
        const fileInput = document.getElementById('fileInput');
        let loadedFiles = new Map();
        const eyeIconVisible = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
        const eyeIconHidden = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.44-4.75C21.27 7.61 17 4.5 12 4.5c-1.74 0-3.4.56-4.82 1.5l2.42 2.42C10.74 7.13 11.35 7 12 7zm-2.28 4.49l2.81 2.81c-.55.23-1.14.36-1.77.36-2.76 0-5-2.24-5-5 0-.63.13-1.22.36-1.77L9.72 9.49zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L21.73 22 23 20.73 3.27 3 2 4.27z"/></svg>`;
        fileInput.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            if (loadedFiles.has(file.name)) {
                alert(`Layer "${file.name}" is already loaded.`);
                fileInput.value = '';
                return;
            }
            let loadedObject;
            const extension = file.name.split('.').pop().toLowerCase();
            try {
                if (extension === 'kml' || extension === 'kmz') {
                    loadedObject = await Cesium.KmlDataSource.load(file, { camera: viewer.scene.camera, canvas: viewer.scene.canvas });
                    await viewer.dataSources.add(loadedObject);
                } else if (extension === 'glb' || extension === 'gltf') {
                    const objectUrl = URL.createObjectURL(file);
                    loadedObject = await Cesium.Model.fromGltf({ url: objectUrl, modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(viewer.camera.positionWC), minimumPixelSize: 128 });
                    viewer.scene.primitives.add(loadedObject);
                } else {
                    alert('Unsupported file format.');
                    return;
                }
                const listItem = document.createElement('li');
                const visibilityToggle = document.createElement('span');
                visibilityToggle.className = 'visibility-toggle';
                visibilityToggle.innerHTML = eyeIconVisible;
                visibilityToggle.onclick = (e) => {
                    e.stopPropagation();
                    loadedObject.show = !loadedObject.show;
                    visibilityToggle.innerHTML = loadedObject.show ? eyeIconVisible : eyeIconHidden;
                };
                const nameSpan = document.createElement('span');
                nameSpan.className = 'layer-name';
                nameSpan.textContent = file.name;
                listItem.ondblclick = () => viewer.flyTo(loadedObject);
                const controls = document.createElement('div');
                controls.className = 'layer-controls';
                const removeBtn = document.createElement('button');
                removeBtn.textContent = 'X';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (loadedObject instanceof Cesium.KmlDataSource) { viewer.dataSources.remove(loadedObject); } 
                    else { viewer.scene.primitives.remove(loadedObject); }
                    listItem.remove();
                    loadedFiles.delete(file.name);
                };
                controls.appendChild(visibilityToggle);
                controls.appendChild(removeBtn);
                listItem.appendChild(nameSpan);
                listItem.appendChild(controls);
                dataLayersList.appendChild(listItem);
                loadedFiles.set(file.name, loadedObject);
                viewer.flyTo(loadedObject);
            } catch (error) {
                console.error(`Error loading file "${file.name}":`, error);
                alert(`Failed to load file: ${file.name}.`);
            }
            fileInput.value = '';
        };
    }

    // --- UNIFIED INTERACTION TOOLS ---
    function setupInteractionTools(viewer) {
        const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
        const display = document.getElementById('measurement-display');
        const measurementDataSource = new Cesium.CustomDataSource('measurements');
        const drawingDataSource = new Cesium.CustomDataSource('drawings');
        viewer.dataSources.add(measurementDataSource);
        viewer.dataSources.add(drawingDataSource);
        let activeTool = null;
        let points = [];
        let isDrawing = false;
        let dynamicEntity = null;
        const measurementButtons = { distance: document.getElementById('distanceBtn'), area: document.getElementById('areaBtn'), volume: document.getElementById('volumeBtn'), };
        const drawingButtons = { rectangle: document.getElementById('drawRectangleBtn'), curve: document.getElementById('drawCurveBtn'), freeDraw: document.getElementById('freeDrawBtn'), note: document.getElementById('addNoteBtn'), };
        const allButtons = { ...measurementButtons, ...drawingButtons };
        document.getElementById('showDrawings').onchange = (e) => drawingDataSource.show = e.target.checked;
        document.getElementById('exportDrawingsBtn').onclick = () => exportToKML(drawingDataSource);
        document.getElementById('clearMeasurementsBtn').onclick = () => {
            measurementDataSource.entities.removeAll();
            display.textContent = 'Select a tool to begin.';
        };
        document.getElementById('clearDrawingsBtn').onclick = () => {
            drawingDataSource.entities.removeAll();
        };
        const clearCurrentTool = () => {
            if (activeTool) allButtons[activeTool].classList.remove('active');
            activeTool = null;
            points = [];
            if (dynamicEntity) { viewer.entities.remove(dynamicEntity); dynamicEntity = null; }
        };
        const activateTool = (toolName) => {
            if (activeTool === toolName) {
                clearCurrentTool();
                return;
            }
            clearCurrentTool();
            activeTool = toolName;
            allButtons[toolName].classList.add('active');
            display.textContent = `Click to draw. Right-click or release mouse to finish.`;
        };
        Object.keys(allButtons).forEach(key => { allButtons[key].onclick = () => activateTool(key); });
        const getPoint = (event) => viewer.scene.pickPosition(event.position || event.endPosition);
        handler.setInputAction((event) => {
            const position = getPoint(event);
            if (!activeTool || !Cesium.defined(position)) return;
            if (activeTool === 'freeDraw') {
                isDrawing = true;
                points.push(position);
                dynamicEntity = drawingDataSource.entities.add({ polyline: { positions: new Cesium.CallbackProperty(() => points, false), width: 3, material: Cesium.Color.ORANGE } });
                return;
            }
            if (activeTool === 'note') {
                const noteText = prompt("Enter note text:", "Annotation");
                if (noteText) { drawingDataSource.entities.add({ position, point: { pixelSize: 10, color: Cesium.Color.ORANGE }, label: { text: noteText, font: '14pt sans-serif', fillColor: Cesium.Color.WHITE, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(0, -15), disableDepthTestDistance: Number.POSITIVE_INFINITY } }); }
                clearCurrentTool();
                return;
            }
            points.push(position);
            const dataSource = measurementButtons[activeTool] ? measurementDataSource : drawingDataSource;
            dataSource.entities.add({ position, point: { pixelSize: 8, color: Cesium.Color.YELLOW, disableDepthTestDistance: Number.POSITIVE_INFINITY } });
            if ((activeTool === 'distance' || activeTool === 'rectangle') && points.length === 2) {
                finalize();
            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
        handler.setInputAction(() => {
            if (isDrawing && activeTool === 'freeDraw') { finalize(); }
            isDrawing = false;
        }, Cesium.ScreenSpaceEventType.LEFT_UP);
        handler.setInputAction(() => {
            if (points.length >= 2 && activeTool === 'curve') {
                finalize();
            } else if (points.length >= 3 && (activeTool === 'area' || activeTool === 'volume')) {
                finalize();
            }
        }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
        handler.setInputAction((event) => {
            const position = getPoint(event);
            if (!activeTool || !Cesium.defined(position)) return;
            if (isDrawing && activeTool === 'freeDraw') {
                points.push(position);
                return;
            }
            if(points.length === 0) return;
            if (activeTool === 'distance') {
                if (!dynamicEntity) dynamicEntity = viewer.entities.add({ polyline: { positions: [points[0], position], width: 3, material: Cesium.Color.YELLOW.withAlpha(0.5) }});
                dynamicEntity.polyline.positions = [points[0], position];
            } else if (activeTool === 'rectangle') {
                if (!dynamicEntity) dynamicEntity = viewer.entities.add({ rectangle: { coordinates: Cesium.Rectangle.fromCartesianArray([points[0], position]), material: Cesium.Color.ORANGE.withAlpha(0.5) } });
                dynamicEntity.rectangle.coordinates = Cesium.Rectangle.fromCartesianArray([points[0], position]);
            } else if (activeTool === 'curve' || activeTool === 'area' || activeTool === 'volume') {
                const currentPoints = [...points, position];
                if (currentPoints.length >= 2) {
                    if (!dynamicEntity) {
                        const isPolygon = activeTool === 'area' || activeTool === 'volume';
                        dynamicEntity = viewer.entities.add({
                            polyline: { positions: new Cesium.CallbackProperty(() => [...points, position], false), width: 3, material: Cesium.Color.ORANGE.withAlpha(0.7) },
                            polygon: isPolygon ? { hierarchy: new Cesium.CallbackProperty(() => new Cesium.PolygonHierarchy([...points, position]), false), material: Cesium.Color.YELLOW.withAlpha(0.5) } : undefined
                        });
                    }
                }
            }
        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
      
        const finalize = () => {
            let dataSource = measurementButtons[activeTool] ? measurementDataSource : drawingDataSource;
            if (activeTool === 'distance') {
                const distance = Cesium.Cartesian3.distance(points[0], points[1]);
                display.textContent = `Direct Distance: ${distance.toFixed(2)} m`;
                dataSource.entities.add({ polyline: { positions: points, width: 3, material: Cesium.Color.YELLOW } });
            } else if (activeTool === 'area' || activeTool === 'volume') {
                const area = calculate3DArea(points);
                let resultText = `Surface Area: ${area.toFixed(2)} m²`;
                if (activeTool === 'volume') {
                    const cartographics = points.map(p => Cesium.Cartographic.fromCartesian(p));
                    const minHeight = Math.min(...cartographics.map(p => p.height));
                    const maxHeight = Math.max(...cartographics.map(p => p.height));
                    const heightDiff = maxHeight - minHeight;
                    const volume = area * heightDiff;
                    resultText += `\nEst. Volume: ${volume.toFixed(2)} m³`;
                }
                display.textContent = resultText;
                dataSource.entities.add({ polygon: { hierarchy: new Cesium.PolygonHierarchy(points), material: Cesium.Color.YELLOW.withAlpha(0.5) } });
            } else if (activeTool === 'rectangle') {
                 drawingDataSource.entities.add({ rectangle: { coordinates: Cesium.Rectangle.fromCartesianArray(points), material: Cesium.Color.ORANGE.withAlpha(0.5), outline: true, outlineColor: Cesium.Color.ORANGE } });
            } else if (activeTool === 'curve' || activeTool === 'freeDraw') {
                 drawingDataSource.entities.add({ polyline: { positions: points, width: 3, material: Cesium.Color.ORANGE } });
            }
            clearCurrentTool();
        };

        const calculate3DArea = (positions) => {
          if (positions.length < 3) return 0;
          let totalArea = 0;
          for (let i = 1; i < positions.length - 1; i++) {
              const v1 = Cesium.Cartesian3.subtract(positions[i], positions[0], new Cesium.Cartesian3());
              const v2 = Cesium.Cartesian3.subtract(positions[i + 1], positions[0], new Cesium.Cartesian3());
              totalArea += Cesium.Cartesian3.cross(v1, v2, new Cesium.Cartesian3()).magnitude / 2.0;
          }
          return totalArea;
        };
        const exportToKML = (dataSource) => {
            let kml = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n  <Document>\n';
            dataSource.entities.values.forEach(entity => {
                kml += '    <Placemark>\n';
                if (entity.label) kml += `      <name>${entity.label.text.getValue()}</name>\n`;
                if (entity.point) {
                    const cartographic = Cesium.Cartographic.fromCartesian(entity.position.getValue(viewer.clock.currentTime));
                    kml += `      <Point><coordinates>${Cesium.Math.toDegrees(cartographic.longitude)},${Cesium.Math.toDegrees(cartographic.latitude)},${cartographic.height}</coordinates></Point>\n`;
                } else if (entity.polyline) {
                    const positions = entity.polyline.positions.getValue(viewer.clock.currentTime);
                    let coords = '';
                    positions.forEach(p => {
                        const cartographic = Cesium.Cartographic.fromCartesian(p);
                        coords += `${Cesium.Math.toDegrees(cartographic.longitude)},${Cesium.Math.toDegrees(cartographic.latitude)},${cartographic.height} `;
                    });
                    kml += `      <LineString><coordinates>${coords.trim()}</coordinates></LineString>\n`;
                } else if (entity.rectangle) {
                    const rect = entity.rectangle.coordinates.getValue(viewer.clock.currentTime);
                    const coords = [
                        Cesium.Math.toDegrees(rect.west), Cesium.Math.toDegrees(rect.south),
                        Cesium.Math.toDegrees(rect.east), Cesium.Math.toDegrees(rect.south),
                        Cesium.Math.toDegrees(rect.east), Cesium.Math.toDegrees(rect.north),
                        Cesium.Math.toDegrees(rect.west), Cesium.Math.toDegrees(rect.north),
                        Cesium.Math.toDegrees(rect.west), Cesium.Math.toDegrees(rect.south)
                    ].map(c => c.toFixed(6)).join(' ');
                    kml += `      <Polygon><outerBoundaryIs><LinearRing><coordinates>${coords}</coordinates></LinearRing></outerBoundaryIs></Polygon>\n`;
                }
                kml += '    </Placemark>\n';
            });
            kml += '  </Document>\n</kml>';
            const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'quadspectat_drawings.kml';
            link.click();
        };
    }
    
    // --- Run the application ---
    document.addEventListener('DOMContentLoaded', main);
  </script>
</body>
</html>

